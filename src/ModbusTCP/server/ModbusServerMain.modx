MODULE ModbusServerMain
    !***********************************************************
    !
    ! Copyright (c) 2025 ABB Robotics.
    ! Licensed under the MIT License. See LICENSE.txt in the project root for license information.
    !
    !***********************************************************
    !********************COIL ADDRESS TABLE**********************
    ! Type     Address   Access      Description
    ! Coil     0-15      Read        DO Signals  [0]MotorsOn  [1]AutoOn  [2]CycleOn  [3]ExecutionError
    ! Coil     16-31     Read&Write  DI Signals, [16]MotorsOn [17]MotorsOff [18]PPToMain [19]Start [20]Stop
    ! Coil     32-95     Read        DO Signals
    ! Coil     96-159    Read&Write  DI Signals
    !************************************************************

    !*******************REGS ADDRESS TABLE***********************
    ! Type     Format     Modbus Address   Access      Description
    ! Regs     Uint16     0-37             Read        0-37 read-only system holding register, reserved for robot system data,follow IEEE754, 2 Regs => 1 float32
    !                                                  [0][1]ROB1_J1    [2][3]ROB1_J2    [4][5]ROB1_J3    [6][7]ROB1_J4    [8][9]ROB1_J5   [10][11]ROB1_J6
    !                                                  [12][13]ROB1_EXA [14][15]ROB1_EXB [16][17]ROB1_EXC [18][19]ROB1_EXD [20][21]ROB1_EXE [22][23]ROB1_EXF
    !                                                  [24][25]ROB1_X   [26][27]ROB1_Y   [28][29]ROB1_Z   [30][31]ROB1_Rz  [32][33]ROB1_Ry  [34][35]ROB1_Rx  [36][37]ROB1_v
    ! Regs     Uint16    38-49             Read        read-only system holding register,, reserved for robot system data,follow IEEE754, 2 Regs => 1 float32
    ! Regs     Uint16    50-149            Read        read-only user-Send holding register
    ! Regs     Uint16    150-299           Write       read/write user-Rcev holding register
    !************************************************************

    !****************** SHARED REGS******************************
    PERS num MbServerRegsUint16{300};
    !******** MbServer Task Read/Write Multi REGS LOCK **********
    PERS bool Reading32Flag;
    PERS bool Writing32Flag;
    !************************************************************

    !********************SHARED DATA*****************************
    ! [MbServerStatus]: The flag of Server Status,when Status Connected, MbServerStatusis TRUE
    PERS bool MbServerStatus;
    !************************************************************
    ! When modify MbServerConfig IP address as Robot WAN IP, Enabling Rapidsocket in firewall and WARMSTART are REQUIRED!
    CONST ModbusServerConfig MbServerConfig:=["192.168.125.1",502,0.01,0,0,0];
    CONST ModbusServerConfig VirtualConfig:=["127.0.0.1",502,0.01,0,0,0];
    ! [PERIOD_TIME]: Modbus Server Default Response Period 200ms
    LOCAL CONST num PERIOD_TIME:=0.2;
    LOCAL CONST string ModbusServerLogFile:="ModbusServer.txt";
    Task VAR ModbusSocket Server;
    Task VAR ModbusSocket Client;
    Task VAR ModbusServerConfig ServerConfig;

    PROC Main()
        VAR byte mbapBytes{7};
        VAR num mbapLen;
        VAR ModbusMBAP mbap;
        VAR bool timeout:=FALSE;
        VAR byte pduBytes{300};
        VAR num pduLen;
        VAR byte reqBytes{300};
        VAR num reqLen;
        VAR byte resBytes{300};
        VAR num resLen;
        VAR clock clock1;
        VAR num time;
        VAR string clientIP;
        VAR num dataLen;
		VAR bool mbReceived;

        MbServerStatus:=FALSE;
        Reading32Flag:=FALSE;
        Writing32Flag:=FALSE;
        IF NOT MbErrBooked THEN
            MbBookErrNo;
            MbErrBooked:=TRUE;
        ENDIF
        ModbusLogFile:=ModbusServerLogFile;

        IF RobOS() THEN
            ServerConfig:=MbServerConfig;
        ELSE
            ServerConfig:=VirtualConfig;
        ENDIF

        WHILE MbServerStatus=FALSE DO
            SocketClose Server;
            SocketClose Client;
            SocketCreate Server;
            SocketBind Server,ServerConfig.IP,ServerConfig.Port;
            SocketListen Server;
            SocketAccept Server,Client\ClientAddress:=clientIP;   !default wait for 60s
            MbServerStatus:=SocketGetStatus(Server)=SOCKET_LISTENING AND SocketGetStatus(Client)=SOCKET_CONNECTED;
        ENDWHILE
        
        ErrLog ID_INF_MB_COMM_ESTABLISHED\i,ERRSTR_TASK,"Modbus Server","Client IP: "+clientIP+" Port: "+ValToStr(ServerConfig.Port),MB_VERSION,ERRSTR_EMPTY;
        ModbusSync:=TRUE;

        WHILE ModbusSync=TRUE DO
            ClkReset clock1;
            ClkStart clock1;
            ! Receive MBAP
			mbReceived:=FALSE;
            MbReceiveBytes Client,mbapBytes,MBAP_FRAME_LENGTH,mbapLen,ServerConfig.ReceiveTimeOut,timeout;
            IF timeout=FALSE THEN
                mbap:=BytesToMBAP(mbapBytes);
                dataLen:=mbap.Length-1;
                IF 5<=dataLen AND dataLen<=253 THEN
                    ! Receive PDU
                    MbReceiveBytes Client,pduBytes,dataLen,pduLen,ServerConfig.ReceiveTimeOut,timeout;
					mbReceived:=NOT timeout;
				ELSE
                    ErrLog ID_ERR_MB_FORMAT,ERRSTR_TASK,"Invalid MBAP length","Expect length [5,253] bytes, actual "+ValtoStr(dataLen),ERRSTR_UNUSED,ERRSTR_CONTEXT;
				ENDIF
			ENDIF
			! Flush the socket buffer
			MbSocketFlush Client;

            IF mbReceived THEN
                ! Combine MBAP and PDU
                ArrayCombine mbapBytes,MBAP_FRAME_LENGTH,pduBytes,pduLen,reqBytes,reqLen;
                IF ModbusSocketDebug THEN
                    PrintBytes "Receive",reqBytes,reqLen;
                    MbWriteLog ModbusLogFile,"Receive "+clientIP,BytesToStr(reqBytes,reqLen);
                ENDIF
                IF MbCheckRequestFormat(mbap,reqLen)=TRUE THEN
                    ! Update Robot Data for Regs
                    UpdateSystemRegisters;
                    ! Handle Modbus Request and Get Response Bytes
                    MbRequestHandle reqBytes,resBytes,resLen;
                    ! Send Modbus Server Response to Client
                    MbSendBytes Client,ServerConfig,resBytes,resLen;
                ENDIF
            ENDIF
            ClkStop clock1;
            time:=ClkRead(clock1);
            IF time<PERIOD_TIME THEN
                WaitTime PERIOD_TIME-time;
            ENDIF
        ENDWHILE
        SocketClose Client;
        SocketClose Server;
        MbServerStatus:=FALSE;
        ModbusSync:=TRUE;
        WaitTime 0.1;
    ERROR
        IF ERRNO=ERR_SOCK_TIMEOUT THEN
            SkipWarn;
            TRYNEXT;
        ENDIF
        IF ERRNO=ERR_MB_FORMAT OR ERRNO=ERR_MB_FUNCTION THEN
            TRYNEXT;
        ENDIF
        MbServerStatus:=FALSE;
        ExitCycle;
    ENDPROC

    PROC UpdateSystemRegisters()
        VAR robtarget p;
        VAR jointtarget j;
        VAR num rx;
        VAR num ry;
        VAR num rz;
        p:=crobt();
        rx:=EulerZYX(\x,p.rot);
        ry:=EulerZYX(\y,p.rot);
        rz:=EulerZYX(\z,p.rot);
        j:=CJointT();

        ! update MbServerRegsUint16[1-12] with Joint 1-6 value
        MbSysRegsValue{1}:=j.robax.rax_1;
        MbSysRegsValue{2}:=j.robax.rax_2;
        MbSysRegsValue{3}:=j.robax.rax_3;
        MbSysRegsValue{4}:=j.robax.rax_4;
        MbSysRegsValue{5}:=j.robax.rax_5;
        MbSysRegsValue{6}:=j.robax.rax_6;

        ! update MbServerRegsUint16[13-24] with Joint 7-12 value
        MbSysRegsValue{7}:=j.extax.eax_a;
        MbSysRegsValue{8}:=j.extax.eax_b;
        MbSysRegsValue{9}:=j.extax.eax_c;
        MbSysRegsValue{10}:=j.extax.eax_d;
        MbSysRegsValue{11}:=j.extax.eax_e;
        MbSysRegsValue{12}:=j.extax.eax_f;

        ! update MbServerRegsUint16[25-36] with robtarget,
        MbSysRegsValue{13}:=p.trans.x;
        MbSysRegsValue{14}:=p.trans.y;
        MbSysRegsValue{15}:=p.trans.z;
        MbSysRegsValue{16}:=rz;
        MbSysRegsValue{17}:=ry;
        MbSysRegsValue{18}:=rx;

        !update MbServerRegsUint16[37 38] with speed
        MbSysRegsValue{19}:=mb_aospeed*1000;

        FOR i FROM 1 TO 19 DO
            Float32ToTwoUint16 MbSysRegsValue{i},MbServerRegsUint16{2*i-1},MbServerRegsUint16{2*i};
        ENDFOR

    ENDPROC
ENDMODULE
