MODULE ModbusServerInterface(SYSMODULE,VIEWONLY)
    !***********************************************************
    !
    ! Copyright (c) 2025 ABB Robotics.
    ! Licensed under the MIT License. See LICENSE.txt in the project root for license information.
    !
    !***********************************************************
    !********************COIL ADDRESS TABLE*********************
    ! Type     Address   Access      Description
    ! Coil     0-15      Read        DO Signals  [0]MotorsOn  [1]AutoOn  [2]CycleOn  [3]ExecutionError
    ! Coil     16-31     Read&Write  DI Signals, [16]MotorsOn [17]MotorsOff [18]PPToMain [19]Start [20]Stop 
    ! Coil     32-95     Read        DO Signals
    ! Coil     96-159    Read&Write  DI Signals
    !***********************************************************

    !*******************REGS ADDRESS TABLE**********************
    ! Type     Format     Modbus Address   Access      Description
    ! Regs     Uint16     0-37             Read        0-37 read-only system holding register, reserved for robot system data,follow IEEE754, 2 Regs => 1 float32
    !                                                  [0][1]ROB1_J1    [2][3]ROB1_J2    [4][5]ROB1_J3    [6][7]ROB1_J4    [8][9]ROB1_J5   [10][11]ROB1_J6
    !                                                  [12][13]ROB1_EXA [14][15]ROB1_EXB [16][17]ROB1_EXC [18][19]ROB1_EXD [20][21]ROB1_EXE [22][23]ROB1_EXF
    !                                                  [24][25]ROB1_X   [26][27]ROB1_Y   [28][29]ROB1_Z   [30][31]ROB1_Rz  [32][33]ROB1_Ry  [34][35]ROB1_Rx  [36][37]ROB1_v
    ! Regs     Uint16    38-49             Read        read-only system holding register,, reserved for robot system data,follow IEEE754, 2 Regs => 1 float32
    ! Regs     Uint16    50-149            Read        read-only user-Send holding register
    ! Regs     Uint16    150-299           Write       read/write user-Rcev holding register
    !************************************************************

    !******************* REG ADDRESS RANGE **********************
    CONST num SYS_HOLDING_REGISTERS_MIN:=0;
    CONST num SYS_HOLDING_REGISTERS_MAX:=49;
    CONST num USER_SEND_REGISTERS_MIN:=50;
    CONST num USER_SEND_REGISTERS_MAX:=149;
    CONST num USER_RECV_REGISTERS_MIN:=150;
    CONST num USER_RECV_REGISTERS_MAX:=299;
    !************************************************************

    !****************** SHARED REGS******************************
    PERS num MbServerRegsUint16{300};
    !******** MbServer Task Read/Write Multi REGS LOCK **********
    PERS bool Reading32Flag;
    PERS bool Writing32Flag;
    !************************************************************

    !********************SHARED DATA*****************************
    ! [MbServerStatus]: The flag of Server Status,when Status Connected, MbServerStatusis TRUE
    PERS bool MbServerStatus;
    !************************************************************
    ! When modify Modbus Server IP address as Robot WAN IP, Enabling Rapidsocket in firewall and WARMSTART are REQUIRED!
    ! T_MbServer/MbServerConfig ["192.168.125.1",502,0.01,0,0,0]
    
    ! Example code to use the MobusTCP Server Interface to read and write coils and registers in motion task.
    !    PROC MbServerInterfaceExample()
    !        VAR num int16_val;
    !        VAR num uint16_val;
    !        VAR dnum int32_val;
    !        VAR dnum uint32_val;
    !        VAR num float32_val;
    !        VAR num signalVal;
    !        IF IsMbServerConnected =TRUE THEN
    !            !Write and Read Coil
    !            SetDO mb_do32,1;
    !            signalVal:=mb_do33;
    
    !            !Write and Read Regs
    !            MbUpdateSendRegisterInt16 80,-12345;
    !            MbUpdateSendRegisterUint16 82,54321;
    !            MbUpdateSendRegisterInt32 84,-8000000;
    !            MbUpdateSendRegisterUint32 88,8000000;
    !            MbUpdateSendRegisterFloat32 91,123.456;
    !            int16_val:=MbReadRecvUsrRegInt16(152);
    !            uint16_val:=MbReadRecvUsrRegUint16(154);
    !            int32_val:=MbReadRecvUsrRegInt32(156);
    !            uint32_val:=MbReadRecvUsrRegUint32(158);
    !            float32_val:=MbReadRecvUsrRegFloat32(160);
    !        ELSE
    !            TPWrite "Modbus TCP Server connection is lost !";
    !        ENDIF
    !    ENDPROC
    
    FUNC bool IsMbServerConnected()
        RETURN MbServerStatus;
    ENDFUNC

    PROC MbUpdateSendRegisterInt16(num ReqAddress,num Int16IN)
        IF ReqAddress>=USER_SEND_REGISTERS_MIN AND ReqAddress<=USER_SEND_REGISTERS_MAX THEN
            MbServerRegsUint16{ReqAddress+1}:=Int16ToUint16(Int16IN);
        ELSE
            BookErrNo ERR_MB_FUNCTION;
            ErrRaise "ERR_MB_FUNCTION", ID_ERR_MB_FUNCTION,ERRSTR_TASK,MB_FUNCTION_ERR_DESCRIPTION{MB_ILLEGAL_DATA_ADDRESS},"Failed to Write at address "+ValToStr(ReqAddress),ERRSTR_UNUSED,ERRSTR_CONTEXT;
        ENDIF
    ENDPROC

    PROC MbUpdateSendRegisterUint16(num ReqAddress,num UInt16IN)
        IF ReqAddress>=USER_SEND_REGISTERS_MIN AND ReqAddress<=USER_SEND_REGISTERS_MAX THEN
            MbServerRegsUint16{ReqAddress+1}:=UInt16IN;
        ELSE
            BookErrNo ERR_MB_FUNCTION;
            ErrRaise "ERR_MB_FUNCTION", ID_ERR_MB_FUNCTION,ERRSTR_TASK,MB_FUNCTION_ERR_DESCRIPTION{MB_ILLEGAL_DATA_ADDRESS},"Failed to Write at address "+ValToStr(ReqAddress),ERRSTR_UNUSED,ERRSTR_CONTEXT;
        ENDIF
    ENDPROC

    PROC MbUpdateSendRegisterInt32(num ReqAddress,dnum Int32IN)
        ! Wait until the background task of modbus tcp server completed reading SendUsrRegs
        WaitUntil Reading32Flag=FALSE;
        IF ReqAddress>=USER_SEND_REGISTERS_MIN AND ReqAddress<=USER_SEND_REGISTERS_MAX THEN
            I32ToTwoUint16 Int32IN, DINT, MbServerRegsUint16{ReqAddress+1}, MbServerRegsUint16{ReqAddress+2};
        ELSE
            BookErrNo ERR_MB_FUNCTION;
            ErrRaise "ERR_MB_FUNCTION", ID_ERR_MB_FUNCTION,ERRSTR_TASK,MB_FUNCTION_ERR_DESCRIPTION{MB_ILLEGAL_DATA_ADDRESS},"Failed to Write at address "+ValToStr(ReqAddress),ERRSTR_UNUSED,ERRSTR_CONTEXT;
        ENDIF
    ENDPROC

    PROC MbUpdateSendRegisterUint32(num ReqAddress,dnum UInt32IN)
        ! Wait until the background task of modbus tcp server completed reading SendUsrRegs
        WaitUntil Reading32Flag=FALSE;
        IF ReqAddress>=USER_SEND_REGISTERS_MIN AND ReqAddress<=USER_SEND_REGISTERS_MAX THEN
            I32ToTwoUint16 UInt32IN, UDINT, MbServerRegsUint16{ReqAddress+1}, MbServerRegsUint16{ReqAddress+2};
        ELSE
            BookErrNo ERR_MB_FUNCTION;
            ErrRaise "ERR_MB_FUNCTION", ID_ERR_MB_FUNCTION,ERRSTR_TASK,MB_FUNCTION_ERR_DESCRIPTION{MB_ILLEGAL_DATA_ADDRESS},"Failed to Write at address "+ValToStr(ReqAddress),ERRSTR_UNUSED,ERRSTR_CONTEXT;
        ENDIF
    ENDPROC

    PROC MbUpdateSendRegisterFloat32(num ReqAddress,num Float32IN)
        ! Wait until the background task of modbus tcp server completed reading SendUsrRegs
        WaitUntil Reading32Flag=FALSE;
        IF ReqAddress>=USER_SEND_REGISTERS_MIN AND ReqAddress<=USER_SEND_REGISTERS_MAX THEN
            Float32ToTwoUint16 Float32IN, MbServerRegsUint16{ReqAddress+1}, MbServerRegsUint16{ReqAddress+2};
        ELSE
            BookErrNo ERR_MB_FUNCTION;
            ErrRaise "ERR_MB_FUNCTION", ID_ERR_MB_FUNCTION,ERRSTR_TASK,MB_FUNCTION_ERR_DESCRIPTION{MB_ILLEGAL_DATA_ADDRESS},"Failed to Write at address "+ValToStr(ReqAddress),ERRSTR_UNUSED,ERRSTR_CONTEXT;
        ENDIF
    ENDPROC

    FUNC num MbReadRecvUsrRegInt16(num ReqAddress)
        RETURN Uint16ToInt16(MbServerRegsUint16{ReqAddress+1});
    ENDFUNC

    FUNC num MbReadRecvUsrRegUint16(num ReqAddress)
        RETURN MbServerRegsUint16{ReqAddress+1};
    ENDFUNC

    FUNC dnum MbReadRecvUsrRegInt32(num ReqAddress)
        ! Wait until the background task of modbus tcp server completed updating RecvUsrRegs
        WaitUntil Writing32Flag=FALSE;
        RETURN TwoUint16ToI32(MbServerRegsUint16{ReqAddress+1},MbServerRegsUint16{ReqAddress+2}, DINT);
    ENDFUNC

    FUNC dnum MbReadRecvUsrRegUint32(num ReqAddress)
        ! Wait until the background task of modbus tcp server completed updating RecvUsrRegs
        WaitUntil Writing32Flag=FALSE;
        RETURN TwoUint16ToI32(MbServerRegsUint16{ReqAddress+1},MbServerRegsUint16{ReqAddress+2}, UDINT);
    ENDFUNC

    FUNC num MbReadRecvUsrRegFloat32(num ReqAddress)
        ! Wait until the background task of modbus tcp server completed updating RecvUsrRegs
        WaitUntil Writing32Flag=FALSE;
        RETURN TwoUint16ToFloat32(MbServerRegsUint16{ReqAddress+1},MbServerRegsUint16{ReqAddress+2});
    ENDFUNC
    

ENDMODULE
